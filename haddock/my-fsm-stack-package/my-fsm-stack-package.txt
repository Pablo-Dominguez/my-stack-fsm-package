-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | This is a package I created to my dissertation.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/Pablo-Dominguez/my-stack-fsm-package#readme</a>
@package my-fsm-stack-package
@version 0.0.1.0

module Lib
data Automata

-- | This is the main function for creating the Automata abstract data
--   type.
--   
--   Please pay attention to how the object is built. E.g.,
--   
--   <pre>
--   createAutomata s i s0 m a
--   </pre>
--   
--   where:
--   
--   <ul>
--   <li>s is the number of states of the automata.</li>
--   <li>i is the language the automata accepts.</li>
--   <li>s0 is the initial state of the automata.</li>
--   <li>m is the matrix of associations of the automata. (Details here:
--   <a>getAssociations</a>)</li>
--   <li>a is the list of accepting states of the automata.</li>
--   </ul>
--   
--   More specifically you could
--   
--   <pre>
--   import qualified Data.Matrix as M
--   mat = M.fromLists [[2,0,0,0],[2,1,4,0],[1,4,0,0],[0,0,0,3]]
--   tom = createAutomata 4 ['a', 'b', 'c', 'd'] 1 mat [4]
--   </pre>
createAutomata :: Int -> String -> Int -> Matrix Int -> [Int] -> Automata

-- | This function returns the set of states of the automata. It is really
--   of not much use since the generation of the automata only needs the
--   number of states and not the whole set of them, but just in case you
--   want to check which states does the current automata have.
getStates :: Automata -> Set Int

-- | This function returns the list of accepting states of the automata. It
--   is a list and not a set for coherence purpouses. When you build the
--   automata you have to give a list of accepting states so I though it
--   made sense to also return a list of accepting states as the accessing
--   function.
getAcceptingStates :: Automata -> [Int]

-- | This function returns the current initial state of the automata.
getInitialState :: Automata -> Int

-- | This function returns the string of inputs that the automata accepts.
getInputs :: Automata -> String

-- | This function returns the associations matrix of the automata. This
--   matrix is built according to the following rules:
--   
--   <ol>
--   <li>The columns of the matrix represent the inputs of the language
--   that the automata accepts in lexicographical order.</li>
--   <li>The rows of the matrix represent the states of the automata in
--   ascending order.</li>
--   <li>The element &lt;math&gt; means that the state &lt;math&gt; is
--   connected to the state &lt;math&gt; thanks to the input that the
--   column &lt;math&gt; of the matrix represents.</li>
--   </ol>
--   
--   Continuing with the previous example, the following matrix correspongs
--   to the automata in the figure.
--   
--   <pre>
--   mat = M.fromLists [[2,0,0,0],[2,1,4,0],[1,4,0,0],[0,0,0,3]]
--   tom = createAutomata 4 ['a', 'b', 'c', 'd'] 1 mat [4]
--   </pre>
--   
--   The code above represent this matrix:
--   
--   <pre>
--       'a' 'b' 'c' 'd'         &lt;= inputs
--     ------------------
--   1 |  2   0   0   0 
--   2 |  2   1   4   0  
--   3 |  1   4   0   0 
--   4 |  0   0   0   3  
--   
--   ^
--   |
--   states
--   </pre>
--   
--   And the matrix above represents the transitions in the following
--   automata:
--   
getAssociations :: Automata -> Matrix Int

-- | This function returns the inputs that a state accepts for
--   transitioning into another state.
getTransitions :: Automata -> Int -> [Char]

-- | This function returns those states of the automata that do not have
--   any input to any other state, i.e., once that a <tt>hole</tt> state is
--   reached, none of the rest of state can be reached anymore for the
--   current execution.
getHoles :: Automata -> Set Int

-- | This function test if a string is <tt><i>valid</i></tt>, i.e., if when
--   the automata receives the string, ends in one of the accepting states.
validInput :: String -> Automata -> Bool

-- | Function for adding a state to an Automata with the list of
--   associations to the other states. If you would want to add a
--   non-connected state, simply enter the list [0,..,0], with as many
--   zeros as possible inputs.
addState :: Automata -> [Int] -> Automata

-- | This function deletes a state and all the connections it has with any
--   other state. Please note that this function automatically reassigns
--   new numbers for the remaining states, so the states and the
--   associations matrix change accordingly. E.g. if you delete in the
--   previous automata the 3rd state, then since the new automata has just
--   3 states, the old 4th state becomes the new 3rd state.
deleteState :: Automata -> Int -> Automata

-- | This function changes the initial state.
changeInitialState :: Automata -> Int -> Automata

-- | This function adds one accepting state
addAcceptingState :: Automata -> Int -> Automata
instance GHC.Show.Show Lib.Automata
