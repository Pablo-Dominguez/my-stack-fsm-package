-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Basic concepts of finite state machines.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/Pablo-Dominguez/my-stack-fsm-package#readme</a>
@package FSM
@version 0.0.3.0

module FSM.Automata
data Automata

-- | This is the main function for creating the Automata abstract data
--   type. By default, the inital state and the current state of the
--   automata are the same.
--   
--   Please pay attention to how the object is built. E.g.,
--   
--   <pre>
--   createAutomata s i s0 m a c0
--   </pre>
--   
--   where:
--   
--   <ul>
--   <li>s is the number of states of the automata.</li>
--   <li>i is the language the automata accepts.</li>
--   <li>s0 is the initial state of the automata.</li>
--   <li>m is the matrix of associations of the automata. (Details here:
--   <a>getAssociations</a>)</li>
--   <li>a is the list of accepting states of the automata.</li>
--   <li>c0 is the placeholder for the current state. If it's the first
--   time defining this Automata, leave it as c0 = s0</li>
--   </ul>
--   
--   More specifically you could
--   
--   <pre>
--   import qualified Data.Matrix as M
--   mat = M.fromLists [[2,0,0,0],[2,1,4,0],[1,4,0,0],[0,0,0,3]]
--   tom = createAutomata 4 ['a', 'b', 'c', 'd'] 1 mat [4] 1
--   </pre>
createAutomata :: Int -> String -> Int -> Matrix Int -> [Int] -> Int -> Automata

-- | This function returns the set of states of the automata. It is really
--   of not much use since the generation of the automata only needs the
--   number of states and not the whole set of them, but just in case you
--   want to check which states does the current automata have.
getStates :: Automata -> Set Int

-- | This function returns the list of accepting states of the automata. It
--   is a list and not a set for coherence purpouses. When you build the
--   automata you have to give a list of accepting states so I though it
--   made sense to also return a list of accepting states as the accessing
--   function.
getAcceptingStates :: Automata -> [Int]

-- | This function returns the current initial state of the automata.
getInitialState :: Automata -> Int

-- | This function returns the string of inputs that the automata accepts.
getInputs :: Automata -> String

-- | This function returns the associations matrix of the automata. This
--   matrix is built according to the following rules:
--   
--   <ol>
--   <li>The columns of the matrix represent the inputs of the language
--   that the automata accepts in <a>lexicographical order</a>.</li>
--   <li>The rows of the matrix represent the states of the automata in
--   ascending order.</li>
--   <li>The element &lt;math&gt; means that the state &lt;math&gt; is
--   connected to the state &lt;math&gt; thanks to the input that the
--   column &lt;math&gt; of the matrix represents.</li>
--   </ol>
--   
--   More info can be found here: <a>Wikipedia: State-transition table</a>
--   
--   Continuing with the previous example, the following matrix correspongs
--   to the automata in the figure.
--   
--   <pre>
--   mat = M.fromLists [[2,0,0,0],[2,1,4,0],[1,4,0,0],[0,0,0,3]]
--   tom = createAutomata 4 ['a', 'b', 'c', 'd'] 1 mat [4] 1
--   </pre>
--   
--   The code above represent this matrix:
--   
--   <pre>
--       'a' 'b' 'c' 'd'         &lt;= inputs
--     ------------------
--   1 |  2   0   0   0 
--   2 |  2   1   4   0  
--   3 |  1   4   0   0 
--   4 |  0   0   0   3  
--   
--   ^
--   |
--   states
--   </pre>
--   
--   And the matrix above represents the transitions in the following
--   automata:
--   
getAssociations :: Automata -> Matrix Int

-- | This function returns the inputs that a state accepts for
--   transitioning into another state.
getTransitions :: Automata -> Int -> Set Char

-- | This function returns those states of the automata that do not have
--   any input to any other state, i.e., once that a <tt>hole</tt> state is
--   reached, none of the rest of state can be reached anymore for the
--   current execution.
getHoles :: Automata -> Set Int

-- | This function test if a string is <tt><i>valid</i></tt>, i.e., if when
--   the automata receives the string, ends in one of the accepting states.
validInput :: String -> Automata -> Bool

-- | This funcion perform the given transition from the current state and
--   changes to a new current state.
performAction :: Automata -> Char -> Automata

-- | Function for adding a state to an Automata with the list of
--   associations to the other states. If you would want to add a
--   non-connected state, simply enter the list [0,..,0], with as many
--   zeros as possible inputs.
addState :: Automata -> [Int] -> Automata

-- | This function deletes a state and all the connections it has with any
--   other state. Please note that this function automatically reassigns
--   new numbers for the remaining states, so the states and the
--   associations matrix change accordingly. E.g. if you delete in the
--   previous automata the 3rd state, then since the new automata has just
--   3 states, the old 4th state becomes the new 3rd state.
deleteState :: Automata -> Int -> Automata

-- | This function changes the initial state.
changeInitialState :: Automata -> Int -> Automata

-- | This function adds one accepting state
addAcceptingState :: Automata -> Int -> Automata
instance GHC.Show.Show FSM.Automata.Automata


-- | <h1>Considerations</h1>
--   
--   One caveat you should always take into account when using this package
--   is that without some data creation from the user, the use of this
--   package is a bit restricted. This happens because the way it is built
--   the package forbids you to use more than one type of information
--   between states (or inside one), so to work around this, if you want to
--   have multiple types of information inside states, do as follows:
--   
--   <pre>
--   data myCustomData = Type1 String | Type2 Int deriving (Show,Eq)
--   </pre>
--   
--   dont forget about the deriving because otherwise it will conflict with
--   the functions in the package.
module FSM.States
type State = Int
type Tag = String
data StateInfo a
data AutomataInfo a

-- | This function takes a State, a Tag and a value and creates an
--   AutomataInfo object containing only the given State with the value and
--   the tag associated to it. E.g.:
--   
--   <pre>
--   createStateInfo 4 "tag" 25
--   </pre>
--   
--   If you created your own data type, you can do as follows:
--   
--   <pre>
--   my_info = createStateInfo 4 "tag" (Type2 Int)
--   </pre>
createStateInfo :: State -> Tag -> a -> AutomataInfo a

-- | This function takes a State, a list of (Tag,value) and Maybe
--   AutomataInfo and returns the AutomataInfo updated with the list of
--   tags given. Please notice that if Nothing is given, it will return the
--   created AutomataInfo while if a (Just AutomataInfo) object is given,
--   it will update the tags in the given state. E.g. (notice that we are
--   using <tt>my_info</tt> from the previous example)
--   
--   <pre>
--   fromlsStateInfo 4 [("foo", Type1 "on"),("bar", Type2 0)] Nothing
--   fromlsStateInfo 4 [("foo", Type1 "on"),("bar", Type2 0)] (Just my_info)
--   </pre>
fromlsStateInfo :: Eq a => State -> [(Tag, a)] -> Maybe (AutomataInfo a) -> AutomataInfo a

-- | This function returns the states of the given AutomataInfo that
--   currently contain some information
getStatesWithInfo :: AutomataInfo a -> [State]

-- | This function returns the tags that a given state contains inside the
--   AutomataInfo
getTagsInState :: AutomataInfo a -> State -> [Tag]

-- | This function returns the information contained in the given state. If
--   <tt>Nothing</tt> is given, then it returns all the information in the
--   state while if <tt>Just tag</tt> is given, it will return only the
--   information inside the given tag. E.g:
--   
--   <pre>
--   getInfoInState my_info 4 Nothing
--   getInfoInState my_info 4 (Just "foo")
--   </pre>
getInfoInState :: AutomataInfo a -> State -> Maybe Tag -> StateInfo a

-- | This function takes a State, Maybe Tag, a value and an AutomataInfo
--   object and updates the value of the Tag in the given State. Please
--   note that if if Nothing is given, it will delete the State. E.g:
--   
--   <pre>
--   alterStateInfo 3 (Just "foo") (Type2 45) my_info
--   </pre>
alterStateInfo :: State -> Maybe Tag -> a -> AutomataInfo a -> AutomataInfo a

-- | This function takes the left-biased union of t1 and t2. It prefers t1
--   when duplicate keys are encountered. Works similarly to
--   <a>Data.Map.union</a>.
unionStateInfo :: AutomataInfo a -> AutomataInfo a -> AutomataInfo a
instance GHC.Classes.Eq a => GHC.Classes.Eq (FSM.States.AutomataInfo a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (FSM.States.StateInfo a)
instance GHC.Show.Show a => GHC.Show.Show (FSM.States.AutomataInfo a)
instance GHC.Show.Show a => GHC.Show.Show (FSM.States.StateInfo a)
